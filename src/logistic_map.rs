use std::error::Error;

// fixed point iteration - value mapped to itself by the function: f(x) = x 
// where the curve intersects the line y=x? Yes
// - repeatedly applying function over and over again 
// - converges to fixed point
// - how fast does it converge?
// - derivative of fixed point < 1 to converge fast
// - or slope > 45 degrees
// attractors vs. repellers
// repeatedly applying x_{n+1} = rx_n(1-x_n)

pub struct LogisticData { pub r: f64, pub data: Vec<f64> }


/// repeatedly applies the quadratic function
/// x - starting value. 0 < x < 1
/// 
/// n - number of iterations
/// 
/// r - constant that modifies the size of the parabola (0.377)
pub fn logistic_map(x: f64, n: i64, r: f64) -> Vec<f64> {
    let mut xprime = r*x*(1.0-x);
    let mut nums = Vec::new();

    for _ in 0..n {
        
        nums.push(xprime);
        xprime = r*xprime*(1.0-xprime);
        
    };

    nums
}



/// runs logistic_map over a range of values
/// 
/// `x` - initial starting value < 1
/// 
/// `n` - number of iterations to run logistic map. In other words, the number of values to get for each logistic map iteration.
/// 
/// `start_r` - starting r value (recall: modifies size of parabola)
/// 
/// `r_step_size` - amount to increment r by
/// 
/// `r_num_steps` - number of times to increase r by
pub fn iterative_logistic_map(x: f64, n: i64, start_r: f64, r_step_size: f64, r_num_steps: i64) -> Vec<LogisticData> {
    let mut logistic_map_outputs = Vec::new();
    let mut start = start_r;

    for _i in (0..r_num_steps).into_iter() {
        let output = logistic_map(x, n, start);
        
      
        logistic_map_outputs.push(LogisticData{ r: start, data: output });
        
        start += r_step_size;
    }
    
    logistic_map_outputs
}

/// writes logistic data to an existing csv file at `file_path`
/// 
/// `data` - logisitc map data, typically generated by the `iterative_logistic_map` function
/// 
/// `file_path` - directory to existing .csv file 
/// 
pub fn write_logistic_data(data: Vec<LogisticData>, file_path: &str) -> Result<(), Box<dyn Error>> {

    let mut wtr = csv::Writer::from_path(file_path)?;
    let mut headers = (0..data[0].data.len()).rev().map(|x: usize| -> String {x.to_string()}).collect::<Vec<String>>();
    headers.push(String::from("r"));
    headers.reverse();

    wtr.write_record(&headers)?;

    for row in data {
        let mut full_row = Vec::new();
        let mut temp_row = row.data;
        // implicit structure is r, val1,val2,...,valn
        // so we push r to the first column, then add the rest of the values
        full_row.push(row.r);
        full_row.append(&mut temp_row);
        
        let final_row = full_row.iter().map(|x: &f64| -> String {x.to_string()}).collect::<Vec<String>>();

        wtr.write_record(&final_row)?;
    }

    // A CSV writer maintains an internal buffer, so it's important
    // to flush the buffer when you're done.
    wtr.flush()?;
    Ok(())
}

